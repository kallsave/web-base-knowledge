## 性能优化
-----------
### 表现和原因
-----------
- 1.首屏速度慢
  定义: 从抓取到html文档到页面的可视范围内的元素都渲染完成
  - 1. http强缓存和协商缓存

- 2.交互渲染/动画卡顿
  定义: 顺畅的FPS是60左右,小于60太多(30左右)说明更新频率被滞后了,(一次宏任务开始时间到下一个宏任务开始时间超过16.7ms),出现卡顿现象
  - 1. JS引擎线程在一定时间执行占用过多时间, 导致GUI线程一直无法工作,其它任务队列结果也无法及时通过JS引擎线程消费,具体的原因是
      - a.在处理密集型计算（通过web-worker来优化)
      - b.内存占用过多了,导致用于JS引擎执行的上下文可用堆,垃圾回收算法等处理变慢(管理好内存,及时销毁,有效的内存使用)。
      - c.过多的重排语句
  - 2. GUI线程进入工作后占用过多渲染时间,导致JS引擎线程一直无法进入工作,其它任务队列结果也无法及时通过JS引擎线程消费,具体的原因要更新的元素太多(使用diff算法,只更新变化的元素,有效渲染)

- 3.随着使用时间变长,越来越卡

### 解决
-----------
- 1.资源加载优化(资源缓存http和分割文件,当前路由只加载当前所用到的文件)
- 2.页面必要渲染和异步渲染(数据层更新到渲染层做调度处理,交互上算法优化,使用diff算法等,高密集计算优化交给web-worker)
- 3.内存管理
  - 1. https://zhuanlan.zhihu.com/p/490835144
  - 2. https://zhuanlan.zhihu.com/p/393058833


### 性能检测
-----------
- 1. 白屏时间
  定义:

- 2. 首屏时间
  定义: 从抓取到html文档到页面的可视范围内的元素都渲染完成
  单页面计算首屏时间原理: spa单页面应用首屏时间dom渲染是异步的,通过MutationObserver观察body下面的dom变动并记录时间,如果变动次数在连续的几次渲染周期为0,那么这就说明dom稳定了,这个时间就是首屏时间

- 3. 渲染周期
  计算FPS

- 4. 内存指数
  window.performance.memory
  - 1. jsHeapSizeLimit: 上下文可用堆的最大提交,单位字节
  - 2. totalJSHeapSize: 已分配的堆体积,单位字节
  - 3. usedJSHeapSize: 当前js堆活跃端(segment)的体积,单位字节


  ## 框架源码做的优化
  - 1. Vue
    在原生的API中,dom更新是同步的,dom渲染是异步的
    在Vue中,使用虚拟dom,让一次渲染周期内的数据变动所带来的重排重绘,先在vnode中进行修改,然后diff之后对所有产生差异的节点集中一次对dom tree进行修改,所以在vue中,dom更新是异步的,$nextTickVue的一次dom更新周期后触发




